Mux cli is the Openezx name given to Motorola's implementation of the 3GPP 27.010 protocol

3GPP specification [http://www.3gpp.org/ftp/Specs/html-info/27010.htm]


'''Additions'''

Motorola has made a couple of proprietary additions to the standard 27.010 basic protocol.


1. Sequence number & ack

After every receive the AP sends an ack with the sequence number for the next frame
for the BP to use (the sequence number wraps back to zero upon reaching 4).

This addition is unusual for a 27.010 implementation and appears to be a deliberate
mechanism to limit the throughput of the link, potentially a problem with the UART.

  4f = ack command

  Example AP ack frame (flag,dlc(0),ack,len(1),seqnumber(2),crc,flag)
  f9 03 4f 03 02 94 f9


2. Command & Data identification

The advantage of using your own silicon, you can specify enhancements. This simple
addition of command or data for BP->AP flows enables the AP driver to quickly interpret and route
the user packet (useful for identification of GPRS commands and GPRS data - two different ttys).

  Command tag 0x55
  Data tag 0XAA


'''Files'''

  drivers/char/
  ts0710.h
  ts0710_mux.h
  ts0710_mux.c
  ts0710_mux_usb.h
  ts0710_mux_usb.c


'''Current status'''

USB mux code untested due to difficulties with establishing the USB connection to the baseband

The AP works as host. Need to establish hub, dmesg output similar to

  usb.c: registered new driver hub
  ochi_addr = 0xd1239000
  usb-ohci.c: USB OHCI at membase 0xd1239000, IRQ 3

Current focus on the monitoring of GPIO 41 (BP is active)

  drivers/usb
  hub.c usb_hub_port_connect_change  (checking BP patch in e680 & rokre2 code)
  arm/mach-pxa
  ezx.c checking handshake


'''Diagrams'''

The following diagrams use Alessandro Rubini's notation to describe the structure and flows [http://www.linux.it/~rubini/docs/serial/serial.html]. 


'''Simplified receive'''

[[Image:Ts0710_simplified_receive.jpg|simplified receive]]

Steps:
* Interrupt occurs and the driver retrieves the byte stream - data stored in flip buffer (tty_io.c) and entry added to work queue by mux_dispatcher.
* At some point later, when out of interrupt context, the work queue processing is invoked and at some further point of time the receive_worker method is executed. Data is retrieved from the tty buffer and if valid length and crc, passed to ts0710_recv_data (note that the receive_worker also does the AP ack of the frame).
* The ts0710_recv_data method handles the 07.10 protocol, the decode and control responses for the protocol. In this example the frame contains user data (a UIH frame). The DLC is mapped to the correct tty and control transferred to the receive_buf function for the line discipline related to that tty.
* The line discipline holds the data until a user read is actioned, at which point it transfers the data to userspace (via /dev/muxN) or onwards to TCP/IP (via netif_rx).



'''Simplified write'''

[[Image:ts0710_write_simplified.jpg|simplified receive]]

Steps:
* Write is invoked from user space or the TCP/IP stack on the line discipline. To the line discipline the mux code looks like any other driver. The data is passed to the driver, via tty_io, by use of the driver write function pointer.
* The mux_write function validates the state of the associated DLC (see mapping at bottom of page) and if connected, stores the data as a UIH frame in the mux_send_info array. If not already scheduled the work queue is enabled and control returns to the line discipline with the number of bytes 'written'.
* At some point later, the work queue invokes the send_worker function which transfers the data to the basic_write method and onwards to the underlying driver (usb currently).




'''TODO - coming soon'''

diagram showing frame definitions

alterations done for 2.6 - work queues & Alan Cox's replacement of tty flip buffers 

gprsv line discipline - detail the concatenation of data to create IP packets & placement on netif_rx

CSD handling - conventional ppp line discipline

Potential future - mux line discipline (will enable use of any tty_driver derived driver)

Distant future - standardise the implementation - test with a range of basebands (TI-Condat, Agere-Optimay, TTPCom etc) - enable inclusion of advanced mode & convergence layers. Emulation of link.



'''Handy lookup'''

{| border="1" cellpadding="2"
|+ DLC to /dev/mux mapping ''(from ts0710_mux.h)''
! DLC !! Description !! Cmd !! Data
|-
|0 || Control Channel || - || -
|-
|1 || Voice Call & Network MM || 0 || 
|-
|2 || SMS MO || 1 || 
|-
|3 || SMS MT || 2 || 
|-
|4 || Phonebook SIM || 3 || 
|-
|5 || Misc || 4 || 
|-
|6 || CSD / Fax || 5 || 8
|-
|7 || GPRS 1 || 6 || 9
|-
|8 || GPRS 2 || 7 || 10
|-
|9 || Logger CMD ||  || 11
|-
|10 || Logger Data ||  || 12
|-
|11 || Test CMD ||  || 13
|-
|12 || AGPS ||  || 14
|-
|13 || NetMonitor ||  || 15
|-
|}

 TCmd - provides test commands
 Log - debugging info from BP and DSP
 NetMonitor - data from BP (also nm kernel module)
